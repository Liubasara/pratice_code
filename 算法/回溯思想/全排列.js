/** 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
 * 输入: [1,2,3]
 * 输出:
 *[
 *  [1,2,3],
 *  [1,3,2],
 *  [2,1,3],
 *  [2,3,1],
 *  [3,1,2],
 *  [3,2,1]
 *]
 * @param {number[]} nums
 * @return {number[][]}
 */
function permute (nums) {
  /** 回溯法经典题目：全排列
   * 回溯题目的主要特征：给定一段有边界的输入，找出某种规则下的所有排列内容而不是个数，这就要求我们构建出一个树模型并取出所有符合条件的路径
   * 回溯法通常思路：
   *  1. 根据所给的规则列出树状排列，得出所求路径，抛除不需要的路径
   *  2. 定义深度优先遍历函数 dfs，遍历坑位的可选值，对已选值进行标记
   *  3. 进行深度优先遍历，深度遍历完毕后，清除已选值的标记
   * 
   * 模型：
   *  function xx (入参) {
   *    ...前期的变量定义、缓存等准备工作
   *    const path = [] // 定义路径栈
   * 
   *    // 定义深度遍历函数
   *    function dfs (递归参数) {
   *      if (递归边界) {
   *        ...结合题意处理边界逻辑，往往是将当前的路径入栈或抛弃
   *        return
   *      }
   *      // 也有可能不是 for，总归是要遍历所有的可选的坑位
   *      for (遍历坑位可选值) {
   *        ...标记当前可选值，通常会在外层使用一个 map 结构来进行标记
   *        path.push(当前选中值) // 处理当前可选值的相关操作，如入栈当前路径
   *        dfs(递归参数处理) // 进入下一层，对递归参数进行限制
   *        ...清除已选值的标志
   *        path.pop() // 递归完成后返回该层需要的操作，如 pop 当前值
   *      }
   *    }
   * 
   *    return path
   *  }
   */
  const path = [] // 所有排列路径的数组，必含变量
  const curr = [] // 记录当前的排列内容
  const len = nums.length
  const visit = new Map() // 标记当前坑位是否已被使用，必含变量
  function dfs (nth) { // 入参是坑位的索引
    // 递归结束条件，进入第三层，即树的最底层，curr 中的长度与坑位数量相等
    if (curr.length === len) {
      path.push([...curr]) // 将当前对应的排列记下来
      return
    }
    // 检查手里剩下的数字有哪些
    for (let i = 0; i < len; i++) {
      // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
      if (!visit.get(nums[i])) {
        visit.set(nums[i], true) // 给 nums[i] 打个“已用过”的标
        curr.push(nums[i]) // 将nums[i]推入当前排列
        dfs() // 基于该排列继续进行下一层深度遍历
        curr.pop() // 遍历完成，返回本层，让出当前坑位
        visit.set(nums[i], false) // 遍历完成，返回本层，去除该坑位的标签留待同层级的节点使用（因为同层级的下一层节点的值有可能就是本节点的值）
      }
    }
  }
  dfs()
  return path
}

console.log(permute([1, 2, 3]))
