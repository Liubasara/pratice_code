// 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

//

// 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

//

// 示例 1:

// 输入: 1
// 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
// 示例 2:

// 输入: 2
// 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

// 输入：3
// 输出：[0.00463,0.01389,0.02778,0.0463,0.06944,0.09722,0.11574,0.125,0.125,0.11574,0.09722,0.06944,0.0463,0.02778,0.01389,0.00463]

// 题解：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/jian-zhi-offer-60-n-ge-tou-zi-de-dian-sh-z36d/

/**
 * 当骰子为 1 个时，有 6 个结果
 * 当骰子为 2 个时，有 11 个结果
 * 当骰子为 3 个时，有 16 个结果
 * 当骰子为 n 个时，有 5n + 1 个结果
 *
 * 假设已知 n - 1 个骰子的解 f(n - 1) ，此时添加一枚骰子，求 n 个骰子的点数和为 x 的概率 f(n, x)。
 * 当添加骰子的点数为 1 时，前 n - 1 个骰子的点数和应为 x - 1，方可组成点数和 x；
 * 同理，当此骰子为 2 时，前 n - 1 个骰子应为 x - 2；以此类推，直至此骰子点数为 6 。
 * 将这 6 种情况的概率相加，即可得到概率 f(n, x) 。
 */

/**
 * @param {number} n
 * @return {number[]}
 */
var dicesProbability = function (n) {
  const dp = [0, new Array(6).fill(1 / 6)]
  for (let i = 2; i <= n; i++) {
    dp[i] = new Array(5 * i + 1)
    for (let j = 0; j < dp[i].length; j++) {
      const x = i + j // 当前和
      dp[i][j] = 0
      for (let k = 1; k <= 6; k++) {
        const lastMin = i - 1
        // x - k - lastMin 为上一个和为 x - k 的概率
        if (x - k - lastMin >= 0 && dp[i - 1][x - k - lastMin]) {
          dp[i][j] += dp[i - 1][x - k - lastMin]
        }
      }
      dp[i][j] *= 1 / 6
    }
  }
  return dp[n]
}

console.log(dicesProbability(3))
