/**
二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树:
  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。
  
96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
**/

/**
  背景条件：设 n 个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则：
              G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)
            对于二叉树的数量，选取一个结点为根，就把结点切成左右子树，以这个结点为根的可行二叉树数量就是左右子树可行二叉树数量的乘积
            当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则：
              f(i)=G(i−1)∗G(n−i)
            综合上面可得：
              G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)
            这样的公式也被称为卡特兰公式
  思考过程：
    1. 设 dp[i] 为以 i 为节点组成的二叉搜索树种类，则该题的返回目标为 dp[n]
    2. 推出状态转移方程：根据卡特兰公式，可得出 dp[i] += dp[j - 1]*dp[i - j] (i=2 递增且小于 n + 1，j=1 递增且小于 i + 1)
    3. 搞定初始状态：dp[0] = 1，dp[1] = 1
**/

/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function(n) {
  var dp = new Array(n + 1).fill(0)
  dp[0] = 1
  dp[1] = 1
  
  for (var i = 2; i < n + 1; i++) {
    for (var j = 1; j < i + 1; j++) {
      dp[i] += dp[j - 1]*dp[i - j]
    }
  }
  return dp[n]
};

console.table(numTrees(3))
