# 单链表（3）

---

## 单链表的整表删除

单链表整表删除的算法思路如下：

- 声明结点p和q；
- 将第一个结点赋值给p，下一个结点赋值给q；
- 循环执行释放p和将q赋值给p的操作；

示例代码如下：

```c
Status ClearList(LinkList *L){
    LinkList p, q;
    p = (*L)->next;
    while(p){
        q = p->next;
        free(p);
        p = q;
    }
    (*L)->next = NULL;
    return OK;
}
```

---

## 单链表结构与顺序存储结构优缺点

### 存储分配方式

- 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
- 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素

### 时间性能

- 查找
  - 顺序存储结构O(1)
  - 单链表O(n)
- 插入和删除
  - 顺序存储结构需要平均移动表长一半的元素，时间为O(N)
  - 单链表在计算出某位置的指针后，插入和删除时间仅为O(1)

### 空间性能

- 顺序结构需要预分配存储空间，容易造成空间浪费
- 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制

**综上所述对比，可以得出一些结论：**==若线性表需要频繁查找，很少进行插入和删除操作，最好采用顺序存储结构，相反，若需要频繁插入或删除时，宜采用单链表结构。==

---

## 静态链表

用数组描述的链表叫作静态链表，这种描述方法叫作==游标实现法==

```c
/* 线性表的静态链表存储结构 */
#define MACSIZE 1000
typedef struct {
    ElemType data; // 数据
    int cur; // 游标(Cursor)
}Component, StaticLinkList[MAXSIZE];
```

由数组所描述的静态链表StaticLinkList[MAXSIZE]中，StaticLinkList[0]和StaticLinkList[MAXSIZE]的data都是不存储数据的。其游标分别是最后一个没有存储数据的下标，和第一个有存储数据的下标。而StaticLinkList剩余的数据的游标的值则是下一个数据的下标的值。具体情况如下图：![静态链表](G:\bilibili_pa\git_work\code-git\数据结构和算法笔记\静态链表.png)

对静态链表进行初始化相当于初始化数组：

```c
Status InitList(StaticLinkList space){
    int i;
    for(i=0; i<MAXSIZE-1;i++) space[i].cur = i+1;
    space[MAXSIZE-1].cur = 0;
    return OK;
}
```

